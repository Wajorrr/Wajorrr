import{E as n}from"./style.514c0d27.js";import{d as r,r as a,m as e,a as i,u as $,G as t,F as o,o as _}from"./index.a20f2826.js";var c="# 快速傅里叶变换 (FFT)\r\n\r\n- [快速傅里叶变换 (FFT)](#快速傅里叶变换-fft)\r\n  - [1. 前置知识](#1-前置知识)\r\n    - [1.1. 复数](#11-复数)\r\n      - [1.1.1. 复数的引入](#111-复数的引入)\r\n      - [1.1.2. 复数的几何意义](#112-复数的几何意义)\r\n      - [1.1.3. 复数的运算](#113-复数的运算)\r\n        - [1.1.3.1. 复数的加法与减法](#1131-复数的加法与减法)\r\n        - [1.1.3.2. 复数的乘法与除法](#1132-复数的乘法与除法)\r\n        - [1.1.3.3. 复数运算与复平面上的向量的对应关系](#1133-复数运算与复平面上的向量的对应关系)\r\n    - [1.2. 欧拉公式](#12-欧拉公式)\r\n    - [1.3. 多项式](#13-多项式)\r\n      - [1.3.1. 多项式的表示](#131-多项式的表示)\r\n      - [1.3.2. 朴素的多项式乘法](#132-朴素的多项式乘法)\r\n  - [2. 算法介绍](#2-算法介绍)\r\n  - [3. 原理概述](#3-原理概述)\r\n  - [4. 原理详解](#4-原理详解)\r\n    - [4.1. 傅里叶变换](#41-傅里叶变换)\r\n      - [4.1.1. 离散傅里叶变换/逆变换的计算公式](#411-离散傅里叶变换逆变换的计算公式)\r\n    - [4.2. 多项式乘法与快速傅里叶变换](#42-多项式乘法与快速傅里叶变换)\r\n    - [4.3. 离散傅里叶变换计算式的证明](#43-离散傅里叶变换计算式的证明)\r\n      - [4.3.1. 单位复根](#431-单位复根)\r\n      - [4.3.2. 离散傅里叶变换计算式](#432-离散傅里叶变换计算式)\r\n    - [4.4. 使用离散傅里叶变换计算多项式乘法](#44-使用离散傅里叶变换计算多项式乘法)\r\n    - [4.5. 使用快速傅里叶变换加速对离散傅里叶变换计算式的计算](#45-使用快速傅里叶变换加速对离散傅里叶变换计算式的计算)\r\n      - [4.5.1. 快速傅里叶变换](#451-快速傅里叶变换)\r\n      - [4.5.2. 代码实现](#452-代码实现)\r\n      - [4.5.3. 快速傅里叶变换的优化](#453-快速傅里叶变换的优化)\r\n        - [4.5.3.1. 蝴蝶变换](#4531-蝴蝶变换)\r\n        - [4.5.3.2. \"三步变两步\"优化](#4532-三步变两步优化)\r\n  - [5. 代码模板](#5-代码模板)\r\n  - [6. 相关题目](#6-相关题目)\r\n    - [6.1. 使用快速傅里叶变换加速计算大整数乘法](#61-使用快速傅里叶变换加速计算大整数乘法)\r\n\r\n## 1. 前置知识\r\n\r\n### 1.1. 复数\r\n\r\n#### 1.1.1. 复数的引入\r\n\r\n从方程的角度看，**负实数能不能开平方**，就是方程 $x^2+a=0(a>0)$ 有没有解，进而可以归结为**方程 $\\boldsymbol{x^2+1=0}$ 有没有解**。\r\n\r\n回顾**已有的数集扩充过程**，可以看到，每次扩充都与**实际需求**密切相关。例如，为了解决**正方形对角线的度量**，以及 $x^2-2=0$ 这样的方程在**有理数集**中**无解**的问题，人们把**有理数集扩充到了实数集**。数集扩充后，在**实数集**中规定的**加法运算、乘法运算**，与原来在**有理数集**中规定的**加法运算、乘法运算协调一致**，并且**加法和乘法**都满足**交换律和结合律**，**乘法对加法**满足**分配律**。\r\n\r\n依照这种思想，为了解决 $x^2+1=0$ 这样的方程在实数系中无解的问题，我们设想引入一个新数 $i$，使得 $x=i$ 是方程 $x^2+1=0$ 的解，即使得 $i^2=-1$。\r\n\r\n我们之前将**有理数集扩充到实数集**后，**原先的运算性质都得到了保持**，如实数 $1+\\sqrt{3}$ 为一个有理数加上一个无理数，其仍能**与实数集中的任意数**进行**原先的任意运算**，运算结果**仍为一个实数**。  \r\n现在我们把新引进的数 $i$ 添加到实数集中，我们希望数 $i$ 和实数之间仍然能**像实数那样进行加法和乘法运算**，并希望**加法和乘法都满足交换律、结合律**，以及**乘法对加法满足分配律**。那么，实数系经过扩充后，得到的**新数系由哪些数组成**呢？\r\n\r\n依照以上设想，把实数 $b$ 与 $i$ 相乘，结果记作 $a+bi$；把实数 $a$ 与 $bi$ 相加，结果记作 $a+bi$。注意到所有实数以及 $i$ 都可以写成 $\\boldsymbol{a+bi(a,b\\in R)}$ 的形式，从而**这些数都在扩充后的新数集中**。\r\n\r\n#### 1.1.2. 复数的几何意义\r\n\r\n我们知道了 $a+bi$ 这样类似的形式的数被称为复数，并且给出了定义和分类，我们还可以挖掘一下更深层的性质。\r\n\r\n我们把所有实数都放在了数轴上，并且发现数轴上的点与实数一一对应。我们考虑对复数也这样处理。\r\n\r\n首先我们定义**复数相等**：两个复数 $z_1=a+bi,z_2=c+di$ 是相等的，当且仅当 $a=c$ 且 $b=d$。\r\n\r\n也就是说，我们可以用唯一的有序实数对 $(a,b)$ 表示一个复数 $z=a+bi$。这样，联想到**平面直角坐标系**，我们可以发现**复数集与平面直角坐标系中的点集一一对应**。好了，我们找到了复数的一种几何意义。\r\n\r\n那么这个平面直角坐标系就不再一般，因为平面直角坐标系中的点具有了特殊意义——表示一个复数，所以我们把这样的平面直角坐标系称为**复平面**，$x$ 轴称为**实轴**，$y$ 轴称为**虚轴**。我们进一步地说：**复数集与复平面内所有的点所构成的集合是一一对应的**。\r\n\r\n我们考虑到学过的平面向量的知识，发现向量的坐标表示也是一个有序实数对 $(a,b)$ ，显然，复数 $z=a+bi$ 对应复平面内的点 $Z(a,b)$，那么它还对应平面向量 $\\overset{\\longrightarrow}{OZ}=(a,b)$，于是我们又找到了复数的另一种几何意义：**复数集与复平面内的向量所构成的集合是一一对应的（实数 $0$ 与零向量对应）**。\r\n\r\n于是，我们由向量的知识迁移到复数上来，定义**复数的模**就是复数所对应的向量的模，即复数 $z=a+bi$ 的模为 $|z|=\\sqrt{a^2+b^2}$。\r\n\r\n于是为了方便，我们常把复数 $z=a+bi$ 称为点 $Z$ 或向量 $\\overset{\\longrightarrow}{OZ}$，并规定相等的向量表示同一个复数。\r\n\r\n并且由向量的知识我们发现，**虚数不可以比较大小**（但是实数是可以的）。\r\n\r\n#### 1.1.3. 复数的运算\r\n\r\n##### 1.1.3.1. 复数的加法与减法\r\n\r\n我们规定，复数的加法规则如下：\r\n\r\n设 $z_1=a+bi,z_2=c+di$，那么\r\n\r\n$$z_1+z_2=(a+c)+(b+d)i$$\r\n\r\n很明显，两个复数的和仍为复数。\r\n\r\n考虑到向量的加法运算，我们发现复数的加法运算符合向量的加法运算法则，这同样证明了复数的几何意义的正确性。\r\n\r\n同样可以验证，复数的加法满足交换律和结合律。\r\n\r\n减法作为加法的逆运算，我们可以通过加法法则与复数相等的定义来推导出减法法则：\r\n\r\n$$z_1-z_2=(a-c)+(b-d)i$$\r\n\r\n这同样符合向量的减法运算。\r\n\r\n##### 1.1.3.2. 复数的乘法与除法\r\n\r\n我们规定，复数的乘法规则如下：\r\n\r\n设 $z_1=a+bi,z_2=c+di$，那么\r\n\r\n$$\\begin{aligned}z_1z_2 &=(a+bi)(c+di)\\\\ &= ac+bci+adi+bdi^2 \\\\ &=(ac-bd)+(bc+ad)i \\end{aligned}$$\r\n\r\n可以看出，两个复数相乘类似于两个多项式相乘，只需要把 $i^2$ 换成 $-1$，并将实部与虚部分别合并即可。\r\n\r\n复数确实与多项式有关，因为复数域是实系数多项式环模掉 $x^2+1$ 生成的理想。（暂时还不理解）\r\n\r\n复数的乘法与向量的向量积形式类似，是由于复数集是数环。\r\n\r\n于是容易知道，**复数乘法满足交换律，结合律和对加法的分配律**。由于满足运算律，我们可以发现**实数域中的乘法公式在复数域中同样适用**。\r\n\r\n除法运算是乘法运算的逆运算，我们可以像计算 $\\frac{1}{\\sqrt{3}+1}$ 那样推导一下：\r\n\r\n$$\\begin{aligned}  \\frac{a+bi}{c+di} &= \\frac{(a+bi)(c-di)}{(c+di)(c-di)} \\\\ &= \\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i \\quad (c+di\\neq 0)  \\end{aligned}$$\r\n\r\n为了分母实数化，我们乘了一个 $c-di$，这个式子很有意义。\r\n\r\n我们定义，当两个虚数实部相等，虚部互为相反数时，这两个复数互为**共轭复数**。通常记 $z=a+bi$ 的共轭复数为 $\\overline{z}=a-bi$。我们可以发现，两个复数互为共轭复数，那么它们**关于实轴对称**。\r\n\r\n##### 1.1.3.3. 复数运算与复平面上的向量的对应关系\r\n\r\n前面我们提到了**复数集**与**复平面内的向量所构成的集合**有一一对应关系。而**复数加减法运算规则和它们所对应的向量的加减法的运算规则相同**，因此**复数的加减法和向量的加减法也有一一对应关系**。\r\n\r\n但是**复数的乘法**却**与向量的乘法有所区别**，复数的乘法运算规则与实数集的乘法运算规则相似，而向量的乘法运算规则却与它们不同，那么**两个复数相乘后得到的复数所对应的向量**与**原来的两个复数所对应的向量**有没有什么联系呢？\r\n\r\n我们再回到刚才的乘法公式：\r\n\r\n$$\\begin{aligned}z_1z_2 &=(a+bi)(c+di)\\\\ &= ac+bci+adi+bdi^2 \\\\ &=(ac-bd)+(bc+ad)i \\end{aligned}$$\r\n\r\n即复数 $z_1=a+bi,z_2=c+di$ 相乘之后的结果 $z_3=(ac-bd)+(bc+ad)i$，它们对应的向量分别是$\\overline{z_1}=(a,b),\\overline{z_2}=(c,d),\\overline{z_3}=(ac-bd,bc+ad)$，它们的模分别是\r\n\r\n$$\r\n\\begin{aligned}\r\n|\\overline{z_1}| &= \\sqrt{a^2+b^2}, \\\\\r\n|\\overline{z_2}| &= \\sqrt{c^2+d^2}, \\\\\r\n|\\overline{z_3}| &= \\sqrt{(ac-bd)^2+(bc+ad)^2} \\\\\r\n&= \\sqrt{(ac)^2-2abcd+(bd)^2+(bc)^2+2abcd+(ad)^2} \\\\\r\n&= \\sqrt{(ac)^2+(bd)^2+(bc)^2+(ad)^2} \\\\\r\n&= \\sqrt{a^2(c^2+d^2)+b^2(c^2+d^2)} \\\\\r\n&= \\sqrt{a^2(c^2+d^2)+b^2(c^2+d^2)} \\\\\r\n&= \\sqrt{(a^2+b^2)(c^2+d^2)} \\\\\r\n&= |\\overline{z_1}|\\cdot |\\overline{z_2}|\r\n\\end{aligned}\r\n$$\r\n\r\n因此**两个复数相乘的得到的复数的模**就等于**这两个复数的模相乘**，**两个复数相乘后得到的复数对应的向量的模**即为**两个复数对应的向量的模相乘**。\r\n\r\n我们再设这三个复数对应的向量 $\\overline{z_1},\\overline{z_2},\\overline{z_3}$ **与 x 轴的夹角**分别为 $\\theta_1,\\theta_2,\\theta_3$，则 $\\sin\\theta_1=\\frac{b}{\\sqrt{a^2+b^2}},\\cos\\theta_1=\\frac{a}{\\sqrt{a^2+b^2}},\\sin\\theta_2=\\frac{d}{\\sqrt{c^2+d^2}},\\cos\\theta_2=\\frac{c}{\\sqrt{c^2+d^2}},\\sin\\theta_3=\\frac{bc+ad}{\\sqrt{(a^2+b^2)(c^2+d^2)}}，\\cos\\theta_3=\\frac{ac-bd}{\\sqrt{(a^2+b^2)(c^2+d^2)}}$\r\n\r\n观察到\r\n\r\n$$\r\n\\begin{aligned}\r\n\\sin(\\theta_1+\\theta_2) &= \\sin\\theta_1\\cos\\theta_2+cos\\theta_1\\sin\\theta_2 \\\\\r\n&= \\frac{b}{\\sqrt{a^2+b^2}} \\cdot \\frac{c}{\\sqrt{c^2+d^2}} + \\frac{a}{\\sqrt{a^2+b^2}} \\cdot \\frac{d}{\\sqrt{c^2+d^2}} \\\\\r\n&= \\frac{bc+ad}{\\sqrt{(a^2+b^2)(c^2+d^2)}} \\\\\r\n&= \\sin\\theta_3\r\n\\end{aligned}\r\n\\\\\r\n\\begin{aligned}\r\n\\cos(\\theta_1+\\theta_2) &= \\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_2 \\\\\r\n&= \\frac{a}{\\sqrt{a^2+b^2}} \\cdot \\frac{c}{\\sqrt{c^2+d^2}} - \\frac{b}{\\sqrt{a^2+b^2}} \\cdot \\frac{d}{\\sqrt{c^2+d^2}} \\\\\r\n&= \\frac{ac-bd}{\\sqrt{(a^2+b^2)(c^2+d^2)}} \\\\\r\n&= \\cos\\theta_3\r\n\\end{aligned}\r\n$$\r\n\r\n因此可知 $\\theta_1+\\theta_2=\\theta_3$，即**两个复数相乘之后所得到的复数对应的向量与 x 轴的夹角**等于**这两个复数对应的向量与 x 轴的夹角之和**\r\n\r\n于是我们得到了两个复数的相乘时，**它们所对应的向量**与**乘得的结果对应的向量**的关系：**两个复数相乘，在复平面上表示为两个向量模长相乘，辐角相加**\r\n\r\n由于**向量没有除法**，这里不讨论复数除法与向量的关系。\r\n\r\n### 1.2. 欧拉公式\r\n\r\n先给出**欧拉公式**：$e^{i\\theta}=\\cos\\theta+i\\sin\\theta$  \r\n欧拉公式揭示了复数指数幂与复数本身之间的联系\r\n\r\n这个公式我们无法在不知道它的情况下有明确目的性地去推得它，它实际上是我们将实数集扩充到复数集并为复数集定义加减乘除以及复数指数幂运算之后自然而然满足的式子，在我们不知道它的情况下，有很多线索可以帮助我们去找到它，欧拉就是在观察泰勒级数时发现了这个公式，从而将复数指数幂运算与实数建立了联系，在我们知道它的情况下，我们也可以用很多方法去证明它。\r\n\r\n**困难：**\r\n我们现在已经将实数集扩充得到了复数集，且为复数规定了一系列实数所具备的加减乘除运算法则，除了这些运算，实数还规定了实数指数幂运算，我们如何应该如何规定复数指数幂运算呢？\r\n\r\n我们将有理数集扩充为实数集时，对于无理数我们虽然无法知道其精确值，但是我们能够知道其近似值，其近似值还是有理数，能够求得一个数的无理数指数幂的无限近似值，因此无理数作为指数是很自然的，但是现在对于复数我们不知道其精确值($i=\\sqrt{-1}$)，一个数的复数指数幂应该得到什么样的结果我们无法得知，因此要将复数指数幂运算纳入复数集，我们就必须将复数的复数指数幂与复数本身之间建立起联系\r\n\r\n**线索：**\r\n\r\n1. 复数的乘法与其对应的复平面向量的关系：我们前面证明了两个复数相乘，在复平面上表示为两个向量模长相乘，辐角相加，于是我们考虑这样一个复数 $\\cos\\theta+\\sin\\theta i$，这个复数对应的向量的模长为 1，辐角为 $\\theta$，因此考虑其幂次显然可以得到：$(\\cos\\theta+\\sin\\theta\\cdot i)^n=\\cos(n\\theta)+\\sin(n\\theta)\\cdot i$，我们将其设为一个函数 $f(\\theta)=\\cos\\theta+\\sin\\theta\\cdot i$，于是有 $f^n(\\theta)=f(n\\theta)$，这**恰好符合实数中指数函数的性质**：$g(t)=x^t,g^n(t)=(x^t)^n=x^{nt}=g(nt)$\r\n\r\n2. 还是考虑复数乘法与其对应复平面向量的关系，在复平面上，1 显然就是实数轴 x 轴上从 0 到 1 的一条直线，如果我们将它乘以 $(1+\\frac{1}{n}\\cdot i)$，它会向上旋转一定的角度并增长一定的长度，而当 n 很大时，$(1+\\frac{1}{n}\\cdot i)$ 的模长近似于 1，与 1 相乘对其模长基本没有影响，而其辐角却可以不断累加，而 $n\\rightarrow \\infty$ 时，1 乘上 $(1+\\frac{1}{n}\\cdot i)^n$ 基本上就是在围绕原点半径为 1 的圆上旋转，而我们知道 $e=\\underset{n\\rightarrow \\infty}{\\lim}(1+\\frac{1}{n})^n$，若引入复数指数幂，可以推得 $\\underset{n\\rightarrow \\infty}{\\lim}(1+\\frac{i}{n})^n=\\underset{n\\rightarrow \\infty}{\\lim}(1+\\frac{i}{n})^{\\frac{n}{i}\\cdot i}=e^i$，即 $e^i$ 代表复平面上的向量的逆时针旋转变换。(实际上 $e^{\\pi i}+1=0$，即 $e^{\\pi i}$ 表示向量旋转了 π 弧度，则一个复平面的向量乘以 $e^i$ 就表示**这个向量逆时针旋转了 1 弧度**，这也是**复数指数幂的几何意义**)\r\n\r\n3. 观察 $e^x,\\sin x,\\cos x$ 的**泰勒展开式**（也是欧拉公式的证明）\r\n   $e^x=1+x+\\frac{1}{2!}x^2+\\frac{1}{3!}x^3+...$\r\n   $\\sin x=x-\\frac{1}{3!}x^3+\\frac{1}{5!}x^5+...$\r\n   $\\cos x=1-\\frac{1}{2!}x^2+\\frac{1}{4!}x^4+...$\r\n   观察到这三个式子形式的相似之处，将 $x=i\\theta$ 带入 $e^x$ 可得：\r\n   $\\begin{aligned}  e^{i\\theta} &= 1+{i\\theta}+\\frac{{(i\\theta)}^2}{2!}+\\frac{{(i\\theta)}^3}{3!}+\\frac{{(i\\theta)}^4}{4!}+\\frac{{(i\\theta)}^5}{5!}+\\frac{{(i\\theta)}^6}{6!}+\\frac{{(i\\theta)}^7}{7!}... \\\\ &= 1+{i\\theta}-\\frac{{\\theta}^2}{2!}-\\frac{{i\\theta^3}}{3!}+\\frac{{\\theta^4}}{4!}+\\frac{{i\\theta^5}}{5!}-\\frac{{\\theta^6}}{6!}-\\frac{{i\\theta^7}}{7!}+... \\\\ &= (1-\\frac{{\\theta}^2}{2!}+\\frac{{\\theta^4}}{4!}-\\frac{{\\theta^6}}{6!})+ ( {i\\theta}-\\frac{{i\\theta^3}}{3!}+\\frac{{i\\theta^5}}{5!}-\\frac{{i\\theta^7}}{7!}) +... \\\\ &= (1-\\frac{{\\theta}^2}{2!}+\\frac{{\\theta^4}}{4!}-\\frac{{\\theta^6}}{6!})+ i( {\\theta}-\\frac{{\\theta^3}}{3!}+\\frac{{\\theta^5}}{5!}-\\frac{{\\theta^7}}{7!}) +... \\\\ &= \\cos\\theta + i\\sin\\theta \\end{aligned}$\r\n\r\n**外加一个求导证明：**\r\n令 $f(x)=\\frac{e^{ix}}{\\cos x+i\\sin x}=\\frac{u}{v}$，对该函数求导：  \r\n$f'(x)=\\frac{u'v-uv'}{v^2}=\\frac{ie^{ix}(\\cos x+i\\sin x)-e^{ix}(-\\sin x+i\\cos x)}{(\\cos x+i\\sin x)^2} = 0$  \r\n因此 $f(x)$ 是一个常值函数，随意带入一个值 $f(0)=1$，因此 $e^{ix}=\\cos x+i\\sin x$\r\n\r\n### 1.3. 多项式\r\n\r\n#### 1.3.1. 多项式的表示\r\n\r\n1. **系数表示法**\r\n\r\n系数表示法就是用一个**多项式各个项的系数**来表达这个多项式，即使用一个系数序列来表示多项式：  \r\n$f(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1} \\Longleftrightarrow f(x)={\\{a_0,a_1,...,a_{n-1}\\}}$\r\n\r\n2. **点值表示法**\r\n\r\n点值表示法是把这个多项式**看成一个函数**，从上面**选取 $n$ 个点**，从而利**用这 $n$ 个点来唯一地表示这个函数**。(**$n$ 个点可以唯一确定这个 $n$ 个参数的函数，即 $n$ 个方程可以解 $n$ 个未知数**)\r\n\r\n#### 1.3.2. 朴素的多项式乘法\r\n\r\n令 $f(x)=a_1x^2+b_1x+c\r\n_1，g(x)=a_2x^2+b_2x+c_2$  \r\n则它们的朴素乘法为：  \r\n$h(x)=f(x)*g(x)=a_1x^2*a_2x^2+a_1x^2*b_2x+a_1x^2*c_2+b_1x*a_2x^2+b_1x*b_2x+b_1x*c_2+c_1*a_2x^2+c_1*b_2x+c_1*c_2$  \r\n对于这两个三度多项式相乘，朴素乘法进行了 9 次运算，复杂度是 $O(n^2)$ ，若 n 非常大，这个复杂度会非常高\r\n\r\n## 2. 算法介绍\r\n\r\n**离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT）**，是**傅里叶变换**在**时域**和**频域**上都呈**离散**的形式，将**信号的时域采样**变换为其离散时间傅里叶变换（DTFT）的**频域采样**。\r\n\r\n**FFT** 是一种**高效实现 DFT** 的算法，称为**快速傅里叶变换（Fast Fourier Transform，FFT）**。它是根据**离散傅氏变换**的**奇、偶、虚、实**等特性，对离散傅立叶变换进行**加速实现**，它对傅里叶变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。**快速数论变换 (NTT)** 是**快速傅里叶变换（FFT）** 在 **数论基础**上的实现。\r\n\r\n在 1965 年，Cooley 和 Tukey 发表了快速傅里叶变换算法。事实上 FFT 早在这之前就被发现过了，但是在当时现代计算机并未问世，人们没有意识到 FFT 的重要性。一些调查者认为 FFT 是由 Runge 和 König 在 1924 年发现的。但事实上高斯早在 1805 年就发明了这个算法，但一直没有发表。\r\n\r\n快速傅里叶变换支持在 $O(n\\log{n})$ 的时间内计算**两个 $n$ 度的多项式的乘法**，比朴素的 $O(n^2)$ 算法更高效。由于**两个整数的乘法也可以被当作多项式乘法**，因此这个算法**也可以用来加速大整数的乘法计算**。\r\n\r\n## 3. 原理概述\r\n\r\n1. **离散傅里叶变换**：**离散傅里叶变换在频域中所用/所得到的**是在**离散时间傅里叶变换的频域中的采样**，这样做是因为计算机无法处理**无限连续域**，因此只能将函数定义在**有限离散点**上，即进行采样来表示函数，因此离散傅里叶变换(DFT)就是为了便于计算机计算而产生的。\r\n\r\n2. **离散傅里叶变换与多项式的关系**：离散傅里叶变换/逆变换是对时域中的一般函数而言的，可以将一般的函数的采样与三角函数的积分的采样相互转换，而如果**要在多项式乘法的计算中利用上离散傅里叶变换**，我们就需要将**一些特定的三角函数值**(即**在离散时间傅里叶变换的频域中的一些采样**)代入多项式的未知数 x 中，**使多项式在形式上满足离散傅里叶变换计算式**\r\n\r\n3. **多项式的系数表示法转点值表示法的过程与离散傅里叶变换的关系**：\r\n\r\n    - 多项式的**系数表示法转为点值表示法**： 我们用**特定的复数(三角函数)**来**代入 x**，**使我们要计算的多项式在形式上满足离散傅里叶变换计算式**，从而可以使用离散傅里叶变换计算得到时域中的若干点，即多项式的点值表示法\r\n    - 把一个多项式的**系数表示法转化为点值表示法**的过程(频域->时域)，就叫做**DFT(离散傅里叶变换)**\r\n\r\n4. **多项式的点值表示法转系数表示法与离散傅里叶逆变换的关系**：\r\n\r\n    - 我们已知一个多项式的点值表示法(时域)，于是**相对地我们可以利用离散傅里叶逆变换公式**得到其在**频域中的若干样本点(系数乘以三角函数)**，其**这若干个样本点的系数即为多项式的系数表示法**。\r\n    - 把一个多项式的**点值表示法转化为系数表示法**的过程(时域->频域)，就是 **IDFT(离散傅里叶逆变换)**\r\n\r\n5. **快速傅里叶变换(FFT)**：**FFT(快速傅里叶变换)** 就是充分利用 **DFT/IDFT 计算式中的指数因子**所具有的**对称性质**和**周期性质**(即**奇、偶、虚、实**等特性)，进而**求出这些短序列相应的 DFT** 并进行**适当组合**，达到**删除重复计算，减少乘法运算和简化结构**的目的(实际上就是**递归分治**)，从而加速 IDFT/DFT 的过程。\r\n\r\n6. **利用快速傅里叶变换加速多项式乘法**：既然多项式可以通过**代入特定的三角函数值满足离散傅里叶变换计算式，从系数表达法转换为点值表达法**(频域->时域)，并**通过离散傅里叶逆变换计算式还原**，那我们可以**将两个要相乘的多项式均通过此方法转换为点值表示法**，然后**将它们的点值表达法对应相乘($O(n)$)**,再**将相乘后的结果还原回系数表示法**，这样**就得到了这两个多项式相乘的结果**，其中的**两次离散傅里叶变换以及一次离散傅里叶逆变换**可以通过**递归分治**来**加速**，每次的复杂度为 $O(n\\log n)$\r\n\r\n## 4. 原理详解\r\n\r\n### 4.1. 傅里叶变换\r\n\r\n首先介绍一下不同种类的信号的傅里叶变换：\r\n\r\n1. **连续时间周期信号**:处理时间连续并且具有周期性的信号，其频域上离散，非周期。(**傅里叶级数**)\r\n2. **连续时间非周期信号**:处理时间连续但是不具有周期性的信号，其频域上连续，非周期。(**连续傅里叶变换**)\r\n3. **离散时间非周期信号**:处理时间离散，不具有周期性的信号，其频域上连续，有周期性。(**离散时间傅里叶变换**)\r\n4. **离散时间周期信号**:处理时间离散，具有周期性的信号，其频域上离散，有周期性。(**近似：离散傅里叶变换将时域信号的采样变换为在离散时间傅里叶变换频域的采样可近似为 此种类型的信号**)\r\n\r\n结论：时域的周期性导致频域的离散性，时域的连续函数在频域形成非周期频谱；而时域的离散性造成频域的周期延拓，时域的非周期性对应于频域的连续函数形式。\r\n\r\n离散傅里叶变换是离散时间信号的频谱在[0,2π]上的 N 点等间隔采样,也就是对序列频谱的离散化,这就是 DFT 的物理意义。\r\n\r\n我们通常所说的傅里叶变换一般指的是**连续傅里叶变换**，即上面所说的第 2 种时域信号到频域信号的变换，能够将**时域中平方可积的函数**变换为**频域中复指数函数的积分形式**，即能将满足一定条件(1. 有限个间断点 2.有限个极值点 3.绝对可积)的某个**函数**表示成**三角函数**（正弦和/或余弦函数）或者它们的**积分**的线性组合。(就像是在分析这个函数的组成成分)\r\n\r\n而**离散傅里叶变换**是傅里叶变换在**时域**和**频域**上都呈现**离散**的形式，它能将**时域信号**的**采样**变换为在 **离散时间傅里叶变换（DTFT）** 频域的**采样**\r\n\r\n算法竞赛中我们常用**离散傅里叶变换(DFT)** 再加上递归分治来快速计算两个多项式的乘法，**多项式的系数表示法**转换为**点值表示法**(相当于从频域到时域)，相对地，把一个多项式的**点值表示法**转化为**系数表示法**的过程(从时域到频域)，就是**离散傅里叶逆变换(IDFT)**。(可能在许多其他地方将时域->频域的变换称为变换，频域->时域的变换称为逆变换，原理都一样，只是叫法有区别)\r\n\r\n#### 4.1.1. 离散傅里叶变换/逆变换的计算公式\r\n\r\n1.  时域->频域：\r\n    -   序列 ${\\{X_n\\}}^{N-1}_{n=0}$的离散傅里叶变换为\r\n\r\n$$x[k]=\\underset{n=0}{\\overset{N-1}{\\sum}}X_ne^{-i2{\\pi}kn/N}$$\r\n\r\n2.  频域->时域：\r\n\r\n$$X_n=\\frac{1}{N}\\underset{n=0}{\\overset{N-1}{\\sum}}x[k]e^{i2{\\pi}kn/N}$$\r\n\r\n### 4.2. 多项式乘法与快速傅里叶变换\r\n\r\n回到原来的问题，计算两个 n 度多项式的乘法，**如果我们能得到这两个 n 度多项式的点值表示法，那么将对应的点值相乘即可 $O(n)$ 地得到它们相乘的结果的点值表示法，然后将其还原回系数表达式即可**，但是即使我们得到了点值表示法，想要**将其还原回系数表示法的形式也是非常困难的**，可以使用**高斯消元**，但是其复杂度为 $O(n^2)$，和系数表示法朴素计算的复杂度一样。\r\n\r\n这就需要引入傅里叶变换了，一般我们讲的傅里叶变换是对连续函数而言，虽然多项式是连续函数，但是我们只能存储其离散点值**样本**，怎么使用傅里叶变换？**(①)** 所幸我们有**离散时间傅里叶变换**，但离散时间傅里叶变换处理时域中**离散但非周期性**的信号(即我们这里的**多项式点值样本**)，其在频域中是**连续且周期性**的，我们这里多项式的**系数也是有限且非周期**的，要如何表示其频域**连续且周期性**的特征呢？**(②)** 所幸我们还有**离散傅里叶变换**，我们可以**将这有限个系数看做原频域的采样**，由于**原频域是周期性的**，因此我们**只需要在一个周期内均匀采样**即可(后面再说明一下这里的‘均匀采样’在这个问题中的含义)，但就算我们解决了时域与频域中样本个数(点值个数与系数个数)的问题，我们的**目的是求多项式的点值表达式，相乘之后，再将其还原回系数表达式**，要**如何让多项式的系数表达式满足离散傅里叶变换的条件呢？(③)** 我们可以将一些**特定的复数值**代入多项式的未知数 x，使其**满足离散傅里叶变换的计算式形式**，从而将**其和其系数的乘积**视作**频域内的样本点**，变换到时域(点值表示法)；而**点值表示法(时域)**可以**直接根据离散傅里叶逆变换计算式**还原为**系数表示法(频域)**，最后一个问题，虽然我们能够通过离散傅里叶变换和逆变换的计算式来完成多项式的点值表示法和系数表示法的相互转换，但是**如果朴素计算，其复杂度还是 $O(n^2)$**，那么我们前面那么多的努力不是就白费了-\\_-||**(④)**，所幸，**离散傅里叶变换的计算式中的复数(三角函数)有着许多良好的性质，我们可以通过递归分治来减少重复计算**，从而使得其时间复杂度降低为 $O(n\\log n)$，我们将这样的算法叫做**快速傅里叶变换(FFT)**。\r\n\r\n再解释说明一下：\r\n\r\n-   **时域内的样本点**即：时域中的函数(即原函数)的若干样本点的点值(即**多项式的点值表示法中的点值**)\r\n\r\n-   **频域内的样本点**即：频域中**该点的函数**(即**系数乘上复数(三角函数)，这若干样本点的系数即为多项式的系数表示法**)\r\n-   **频域中的均匀采样**即：\r\n    1. 在**系数表示法转点值表示法**过程中将**原多项式系数表示法**中的 **n 个系数**看做**多项式所表示的函数**在**频域中一个周期内均匀分布的样本点的系数**\r\n    2. 在**点值表示法转系数表示法**过程中**得到这 n 个均匀分布的样本点的系数(即多项式的系数表示法中的 n 个系数)**\r\n\r\n以上，我们就解决了对多项式乘法计算使用傅里叶变换遇到的四个问题：\r\n①、**时域样本点离散**(多项式的点值表示法只有有限个点，且计算机也只能存储有限个离散点)  \r\n解决方案：**一般的连续傅里叶变换->离散时间傅里叶变换**\r\n②、**频域样本点离散**(多项式的系数表示法只有有限个系数，且计算机也只能存储有限个)  \r\n解决方案：**离散时间傅里叶变换->离散傅里叶变换**\r\n③、含有未知数的多项式**形式上**与离散傅里叶变换计算式要求的形式不符合  \r\n解决方案：**将 n 个特殊的复数代入到多项式的未知数 x 中**，使其满足离散傅里叶变换的计算式\r\n④、朴素按照离散傅里叶变换计算式计算，**复杂度还是 $O(n^2)$**  \r\n解决方案：使用**快速傅里叶变换(FFT)**，即根据离散傅里叶变换计算式中复数(三角函数)的性质，使用**递归分治**的思想简化计算，**将复杂度降低为 $O(n\\log n)$**\r\n\r\n于是现在对于两个 n 度多项式的乘法，我们可以通过使用快速傅里叶变换将它们从系数表示法转换为点值表示法，然后 $O(n)$ 相乘，再通过逆变换还原为系数表示法，一共做了三次 $O(n\\log n)$ 的 FFT 外加一次 $O(n)$ 的相乘，总体时间复杂度 $O(n\\log n)$\r\n\r\n### 4.3. 离散傅里叶变换计算式的证明\r\n\r\n现在我们来**证明离散傅里叶变换的计算式**。\r\n\r\n再给出一次离散傅里叶变换的计算式：\r\n\r\n1.  时域->频域：\r\n    -   序列 ${\\{X_n\\}}^{N-1}_{n=0}$的离散傅里叶变换为\r\n\r\n$$x[k]=\\underset{n=0}{\\overset{N-1}{\\sum}}X_ne^{-i2{\\pi}kn/N}$$\r\n\r\n2.  频域->时域：\r\n\r\n$$X_n=\\frac{1}{N}\\underset{k=0}{\\overset{N-1}{\\sum}}x[k]e^{i2{\\pi}kn/N}$$\r\n\r\n#### 4.3.1. 单位复根\r\n\r\n这两个式子虽然看上去令人头皮发麻，但是观察一下我们会发现其复杂之处主要在于那个 $e$ 的幂次 $e^{i2{\\pi}kn/N}$，能够看出这其中就有我们在前面学习欧拉公式时提到的 $e^i$，前面我们提到过，一个复平面的向量乘以 $e^i$ 就代表将这个向量逆时针旋转一弧度，我们将这个式子变换一下形式 $e^{i2{\\pi}kn/N}=e^{\\frac{i\\cdot 2\\pi}{N}\\cdot kn}$，可以看出，**一个复平面的向量乘以 $e^{\\frac{i\\cdot 2\\pi}{N}}$ 实际上就表示将这个向量逆时针旋转 $\\frac{1}{N}$ 圈，即 $\\frac{2\\pi}{N}$ 弧度**，如此一来，$N$ 是常量，而剩下的两个量 $n,k$ 都是与时域频域的样本的编号相关的变量，这样这个式子也就不难理解了。\r\n\r\n既然 $e^i$ 对应的是复平面上辐角为 1 弧度的单位向量，$e^{\\frac{2\\pi i}{N}}$ 对应的是复平面上辐角为 $\\frac{2\\pi}{N}$ 弧度的单位向量，考虑式中一般的 $e^{k\\cdot{\\frac{2\\pi i}{N}}},(N\\in Z^*,0\\le k\\le N-1)$，我们显然可以得到关于这个复数的一些性质：\r\n\r\n1. $(e^{k\\cdot{\\frac{2\\pi i}{N}}})^N=e^{2k\\pi i}=\\cos{(2k\\pi)}+i\\sin{(2k\\pi)}=1$（旋转一圈，得到 1）\r\n2. $e^{(k\\cdot 2)\\cdot{\\frac{2\\pi i}{N \\cdot 2}}}=e^{\\frac{2\\pi i\\cdot k}{N}}$（将一圈的总份数以及该向量的辐角所占的份数都乘以 2，值不变）\r\n3. $e^{(k+\\frac{N}{2})\\cdot{\\frac{2\\pi i}{N}}}=e^{k\\cdot\\frac{2\\pi i}{N}+\\pi i}=e^{k\\cdot\\frac{2\\pi i}{N}}\\cdot e^{\\pi i}=-e^{k\\cdot\\frac{2\\pi i}{N}}$（旋转 $\\frac{1}{2}$ 圈，变为相反数）\r\n\r\n**快速傅里叶变换就是根据此复数的这些性质对计算式进行递归分治地计算从而降低复杂度的**\r\n\r\n通过观察性质 1：$(e^{k\\cdot{\\frac{2\\pi i}{N}}})^N=1$，我们可以发现，这个式子不就跟方程 $x^N=1$ 一样吗，只不过以往我们解这个方程得到的解只有 1(N 为奇数)以及 ±1(N 为偶数)，而这个式子表明了它的解还可以是 $e^{k\\cdot{\\frac{2\\pi i}{N}}}$，且 k 可以取 0~N-1，因此它的解一下子增多到了 N 个(1 和 -1(N 为偶数时) 会在 k 取 0 和 $\\frac{N}{2}$(N 为偶数时) 时被取到)！\r\n\r\n由此，我们给出可以如下定义：我们称 $x^n=1$ 在复数意义下的解是 **$n$ 次复根**。显然，这样的解有 $n$ 个，设 $\\omega_n=e^{\\frac{2\\pi i}{n}}$ ，则 $x^n=1$ 的解集表示为 $\\{\\omega_n^k|k=0,1,...,n-1\\}$。我们称 $\\omega_n$ 是 **$n$ 次单位复根（the n-th root of unity）**。\r\n\r\n举个例子，当 $n=4$ 时，$\\omega_n=i$，即 $i$ 就是 $4$ 次单位复根：\r\n![](./assets/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2(FFT)/2021-07-22-09-31-31.png)\r\n当 $n=4$ 的时候，相当于把单位圆等分 $n=4$ 份。将每一份按照极角编号，那么我们只要知道 $\\omega_4^1$（因为它的角度是相当于单位角度），就能知道 $\\omega_4^0,\\omega_4^1,\\omega_4^2,\\omega_4^3$。  \r\n$\\omega_4^0$ 恒等于 1，$\\omega_4^2$ 的角度是 $\\omega_4^1$ 的两倍，所以 $\\omega_4^2=(\\omega_4^1)^2=i^2=-1$，依次以此类推。\r\n\r\n刚才我们提到 $e^{k\\cdot{\\frac{2\\pi i}{N}}},(N\\in Z^*,0\\le k\\le N-1)$ 的性质就可以表示为：  \r\n对于任意正整数 n 和整数 k：\r\n\r\n1. $\\omega_n^n=1$\r\n2. $\\omega_n^k=\\omega_{2n}^{2k}$\r\n3. $\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^k \\rightarrow \\omega_{2n}^{k+n}=-\\omega_{2n}^k$\r\n\r\n#### 4.3.2. 离散傅里叶变换计算式\r\n\r\n再回到离散傅里叶变换的计算式，现在我们可以将它这样表示(变换和逆变换正好和之前公式的顺序相反，因为算法竞赛中常将**使用离散傅里叶变换将多项式系数表示法转点值表示法的过程**叫做**变换**，将**其反过程**叫做**逆变换**)：\r\n\r\n1.  **频域->时域(系数表示法->点值表示法)：**\r\n\r\n$$\r\n\\begin{aligned}\r\n    X_n &=\\underset{k=0}{\\overset{N-1}{\\sum}}x[k]e^{i2{\\pi}kn/N}  \\\\\r\n    &\\Downarrow\\\\\r\n    X_n &=\\underset{k=0}{\\overset{N-1}{\\sum}}x[k] \\omega_N^{k\\cdot n} \\\\\r\n    &\\Downarrow\\\\\r\n    X_j&=\\underset{i=0}{\\overset{n-1}{\\sum}}x_i \\omega_n^{i\\cdot j} \\:(j=0,1,2,3,...,n-1) \\quad  (1)\r\n\\end{aligned}\r\n$$\r\n\r\n2.  **时域->频域(点值表示法->系数表示法)：**\r\n    -   序列 ${\\{X_n\\}}^{N-1}_{n=0}$的离散傅里叶变换为\r\n\r\n$$\r\n\\begin{aligned}\r\n    x[k]&=\\frac{1}{n}\\underset{n=0}{\\overset{N-1}{\\sum}}X_n e^{-i2{\\pi}kn/N}  \\\\\r\n    &\\Downarrow\\\\\r\n    x[k]&=\\frac{1}{n}\\underset{n=0}{\\overset{N-1}{\\sum}}X_n \\omega_N^{-k\\cdot n} \\\\\r\n    &\\Downarrow\\\\\r\n    x_i&=\\frac{1}{n}\\underset{j=0}{\\overset{n-1}{\\sum}}X_j \\omega_n^{-i\\cdot j} \\:(i=0,1,2,3,...,n-1) \\quad  (2)\r\n\\end{aligned}\r\n$$\r\n\r\n**我们将式(1)(2)分别写成矩阵形式：**\r\n\r\n$$\r\n\\begin{aligned}\r\nX_j= & \\underset{i=0}{\\overset{n-1}{\\sum}}x_i \\omega_n^{i\\cdot j} \\:(j=0,1,2,3,...,n-1)  \\quad  (1) \\\\\r\n&\\Downarrow\\\\\r\n\\begin{bmatrix}\r\nX_0 \\\\ X_1 \\\\ \\vdots \\\\ X_{n-1}\r\n\\end{bmatrix}\r\n&= \\begin{bmatrix}\r\n\\omega_n^0 & \\omega_n^0 & \\cdots & \\omega_n^0 \\\\\r\n\\omega_n^0 & \\omega_n^1 & \\cdots & \\omega_n^{n-1} \\\\\r\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\r\n\\omega_n^0 & \\omega_n^{n-1} & \\cdots & \\omega_n^{(n-1)^2} \\\\\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix} \\\\\r\n&\\Downarrow \\\\\r\n\\begin{bmatrix}\r\nX_0 \\\\ X_1 \\\\ \\vdots \\\\ X_{n-1}\r\n\\end{bmatrix}\r\n&= T\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix}  \\qquad  (3)\r\n\\end{aligned}\r\n$$\r\n\r\n**其中 $T$ 是 $\\omega_n^{ij}$ 的矩阵**，同理，**对于式(2)**:\r\n\r\n$$\r\n\\begin{aligned}\r\nx_i=&\\frac{1}{n}  \\underset{j=0}{\\overset{n-1}{\\sum}}X_j \\omega_n^{-i\\cdot j} \\:(i=0,1,2,3,...,n-1) \\quad  (2) \\\\\r\n&\\Downarrow\\\\\r\n\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix}\r\n&= \\frac{1}{n}\\begin{bmatrix}\r\n\\omega_n^0 & \\omega_n^0 & \\cdots & \\omega_n^0 \\\\\r\n\\omega_n^0 & \\omega_n^{-1} & \\cdots & \\omega_n^{-({n-1})} \\\\\r\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\r\n\\omega_n^0 & \\omega_n^{-(n-1)} & \\cdots & \\omega_n^{-(n-1)^2} \\\\\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nX_0 \\\\ X_1 \\\\ \\vdots \\\\ X_{n-1}\r\n\\end{bmatrix}  \\\\\r\n&\\Downarrow \\\\\r\n\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix}\r\n&= U\\begin{bmatrix}\r\nX_0 \\\\ X_1 \\\\ \\vdots \\\\ X_{n-1}\r\n\\end{bmatrix}  \\qquad  (4)\r\n\\end{aligned}\r\n$$\r\n\r\n**其中 $U$ 是 $\\omega_n^{-ij}$ 的矩阵乘以 $\\frac{1}{n}$**\r\n\r\n**结合 (3)(4)，我们可以得到：**\r\n\r\n$$\r\n\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix}\r\n= U\\begin{bmatrix}\r\nX_0 \\\\ X_1 \\\\ \\vdots \\\\ X_{n-1}\r\n\\end{bmatrix}\r\n= UT\\begin{bmatrix}\r\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1}\r\n\\end{bmatrix}  \\qquad (5)\r\n$$\r\n\r\n于是我们**只需要证明 (5) 式中的 $UT=I_n$ ($I_n$ 为 n 阶单位矩阵)，就可证明 (1)(2) 式成立**，下面来证明：\r\n\r\n$$\r\n\\begin{aligned}\r\n&\\because T_{ij}=\\omega_n^{ij}，U_{ij}=\\frac{1}{n}\\omega_n^{-ij} \\\\\r\n&\\therefore  (TU)_{ik}=\\overset{n-1}{\\underset{j=0}{\\sum}}T_{ij}U_{jk}=\\frac{1}{n}\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{ij}\\omega_n^{-jk}=\\frac{1}{n}\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{j(i-k)} \\quad (6)\r\n\\end{aligned}\r\n$$\r\n\r\n**令 $p=i-k$，有**\r\n\r\n$$\r\n\\begin{aligned}\r\n\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{j(i-k)} &=\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{jp} \\\\\r\n&= \\omega_n^{0p}+\\omega_n^{1p}+\\cdots+\\omega_n^{(n-1)p}\r\n\\end{aligned}\r\n$$\r\n\r\n**当 $p\\neq 0$ (即 $i\\neq k$) 时，显然这是一个公比 $q=\\omega_n^p$ 的等比数列，由等比数列求和公式得到：**\r\n\r\n$$\r\n\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{jp}=\\frac{(\\omega_n^p)^n-1}{\\omega_n^p-1}=\\frac{(\\omega_n^n)^p-1}{\\omega_n^p-1}=\\frac{(1)^p-1}{\\omega_n^p-1}=0 \\quad (7)\r\n$$\r\n\r\n**而当 $p=0$ (即 $i=k$)时，有：**\r\n\r\n$$\r\n\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{jp}=\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{0}=\\overset{n-1}{\\underset{j=0}{\\sum}} 1 = n  \\quad (8)\r\n$$\r\n\r\n综合(7)(8)，得到：\r\n\r\n$$\r\n(TU)_{ik}=\\frac{1}{n}\\overset{n-1}{\\underset{j=0}{\\sum}}\\omega_n^{j(i-k)}=\r\n\\begin{cases}\r\n1, & i=k \\\\\r\n0, & i\\neq k\r\n\\end{cases}\r\n$$\r\n\r\n$\\therefore TU=I_n$ 得证，(1)(2)式成立\r\n\r\n证毕。\r\n\r\n### 4.4. 使用离散傅里叶变换计算多项式乘法\r\n\r\n在上面，**通过单位复根的引入以及单位复根的一些性质**，我们完成了对离散傅里叶变换计算式的证明，现在我们**再来看看已经被我们证明过的这两个式子**：\r\n\r\n1. $X_j=\\underset{i=0}{\\overset{n-1}{\\sum}}x_i \\omega_n^{i\\cdot j} \\:(j=0,1,2,3,...,n-1)$\r\n\r\n2. $x_i=\\frac{1}{n}\\underset{j=0}{\\overset{n-1}{\\sum}}X_j \\omega_n^{-i\\cdot j} \\:(i=0,1,2,3,...,n-1) $\r\n\r\n如何将**这两个变换式**与**多项式的点值表示法和系数表示法的相互转换**联系起来呢？\r\n\r\n前面我们提到过，**将多项式看做函数，将一些特定的复数值带入其未知数 x 中即可使其满足变换式**\r\n\r\n观察第一个式子我们可以发现：\r\n\r\n**将多项式表示成函数，即令 $f(x)=\\underset{i=0}{\\overset{n-1}{\\sum}}a_ix^i$，再将 n 个 n 次单位复根 $\\omega_n^j (j=0,1,2,...,n-1)$ 分别带入 $f(x)$，可得：**\r\n\r\n$f(\\omega_n^j)=\\underset{i=0}{\\overset{n-1}{\\sum}}a_i{(\\omega_n^j)}^i=\\underset{i=0}{\\overset{n-1}{\\sum}}a_i\\omega_n^{i\\cdot j} (j=0,1,2,...,n-1)$\r\n\r\n**再令 $f(\\omega_n^j)=X_j,a_i=x_i$，即可得到：**\r\n\r\n$X_j=\\underset{i=0}{\\overset{n-1}{\\sum}}x_i \\omega_n^{i\\cdot j} \\:(j=0,1,2,...,n-1)$\r\n\r\n**这正好就是第一个离散傅里叶变换计算式**，而**带入点值的过程**就是**多项式系数表示法转换为点值表示法的过程**，于是我们就**通过将这些 n 次单位复根代入多项式的未知数 x** 从而**在使其满足离散傅里叶变换式的同时得到了多项式相应的点值表示法**，我们可以**通过此法得到需要相乘的两个多项式的点值表示法，然后进行 $O(n)$ 的对应项相乘**，即可得到这两个多项式乘积的点值表示法\r\n\r\n**如何将结果还原回系数表示法呢？**\r\n\r\n我们在前面**已经证明过上面使用的正变换式以及其逆变换式的正确性了**，于是我们**可以直接使用逆变换式(即第 2 个式子)，将得到的 n 个相乘后的点值带入第 2 个式子左边的 $X_k$ 中**，从而**计算得到相乘后的多项式的系数表示法**，**这个逆变换过程与原来的正变换过程的差别**只在于**将式中单位复根的指数乘以了 -1**，并**将最终结果乘以了 $\\frac{1}{n}$**\r\n\r\n还有最后一个问题，**n 次单位复根 $\\omega_n^j$ 在计算机中如何表示呢**？\r\n\r\n我们**可以将其转换为三角函数的形式：**\r\n\r\n$\\omega_n^j=e^{j\\cdot \\frac{2\\pi i}{n}}=e^{i\\cdot\\frac{2\\pi j}{n}}=\\cos({\\frac{2\\pi j}{n}})+i\\sin(\\frac{2\\pi j}{n}) \\quad (j=0,2,...,n-1)$\r\n\r\n于是我们就实现了使用离散傅里叶变换对多项式乘法进行计算，但是朴素计算时间复杂度显然还是 $O(n^2)$，由于需要三次变换，甚至增加了复杂度\r\n\r\n### 4.5. 使用快速傅里叶变换加速对离散傅里叶变换计算式的计算\r\n\r\n#### 4.5.1. 快速傅里叶变换\r\n\r\n现在我们就可以来**分析如何在原计算式基础上通过递归分治思想来实现快速傅里叶变换**了。\r\n\r\n我们前面已经提到过快速傅里叶变换是利用**离散傅里叶变换计算式中的复数即 n 次单位复根**的**一些性质**来递归分治地进行计算的，n 次单位复根的这些性质我们在前面已经证明过了，现在来回顾一下：\r\n\r\n对于任意正整数 n 和整数 k：\r\n\r\n1. $\\omega_n^n=1$\r\n2. $\\omega_n^k=\\omega_{2n}^{2k}$\r\n3. $\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^k \\rightarrow \\omega_{2n}^{k+n}=-\\omega_{2n}^k$\r\n\r\n再回到离散傅里叶变换计算式：\r\n\r\n1. $X_j=\\underset{i=0}{\\overset{n-1}{\\sum}}x_i \\omega_n^{i\\cdot j} \\:(j=0,1,2,3,...,n-1)$\r\n\r\n2. $x_i=\\frac{1}{n}\\underset{j=0}{\\overset{n-1}{\\sum}}X_j \\omega_n^{-i\\cdot j} \\:(i=0,1,2,3,...,n-1)$\r\n\r\n前面我们提到过，**逆变换式相比变换式只是将 n 次单位复根的指数乘以了-1，并将最终结果乘以了 $\\frac{1}{n}$，其余的计算过程均一致**，因此**这里我们只单独考虑第 1 个式子，对第 2 个式子同样适用**：\r\n\r\n我们将式子展开：\r\n\r\n$$\r\n\\begin{aligned}\r\nX_j &= x_0 \\omega_n^{0\\cdot j}+x_1 \\omega_n^{1\\cdot j}+x_2 \\omega_n^{2\\cdot j}+x_3 \\omega_n^{3\\cdot j}+...+x_{n-1} \\omega_n^{(n-1)\\cdot j} \\quad(j=0,1,2,3,...,n-1)\r\n\\\\ &\\Downarrow \\\\\r\nX_j &= x_0 (\\omega_n^{j})^0+x_1 (\\omega_n^{j})^1+x_2 (\\omega_n^{j})^2+x_3 (\\omega_n^{j})^3+...+x_{n-1} (\\omega_n^{j})^{n-1}\r\n\\\\\r\n\\end{aligned}\r\n$$\r\n\r\n不妨设 $n$ 为偶数，我们将 $\\omega_n^j$ 按其指数的奇偶性分成两组：\r\n\r\n$$\r\n\\begin{aligned}\r\nX_j &= x_0 (\\omega_n^{j})^0+x_1 (\\omega_n^{j})^1+x_2 (\\omega_n^{j})^2+x_3 (\\omega_n^{j})^3+...+x_{n-1} (\\omega_n^{j})^{n-1}\r\n\\\\\r\n&=[x_0 (\\omega_n^{j})^0 + x_2 (\\omega_n^{j})^2 + x_4 (\\omega_n^{j})^4 +...+ x_{n-2} (\\omega_n^{j})^{n-2}]+[x_1 (\\omega_n^{j})^1 + x_3 (\\omega_n^{j})^3 + x_5 (\\omega_n^{j})^5 +...+ x_{n-1} (\\omega_n^{j})^{n-1}]\r\n\\\\\r\n&=[x_0 (\\omega_n^{j})^0 + x_2 (\\omega_n^{j})^2 + x_4 (\\omega_n^{j})^4 +...+ x_{n-2} (\\omega_n^{j})^{n-2}] + \\omega_n^j[x_1 (\\omega_n^{j})^0 + x_3 (\\omega_n^{j})^2 + x_5 (\\omega_n^{j})^4 +...+ x_{n-1} (\\omega_n^{j})^{n-2}]\r\n\\\\\r\n&=[x_0 (\\omega_n^{0j}) + x_2 (\\omega_n^{2j}) + x_4 (\\omega_n^{4j}) +...+ x_{n-2} (\\omega_n^{(n-2)j})] + \\omega_n^j[x_1 (\\omega_n^{0j}) + x_3 (\\omega_n^{2j}) + x_5 (\\omega_n^{4j}) +...+ x_{n-1} (\\omega_n^{(n-2)j})]\r\n\\\\\r\n&=[x_0 (\\omega_{\\frac{n}{2}}^{0j}) + x_2 (\\omega_{\\frac{n}{2}}^{1j}) + x_4 (\\omega_{\\frac{n}{2}}^{2j}) +...+ x_{n-2} (\\omega_{\\frac{n}{2}}^{\\frac{(n-2)}{2}j})] + \\omega_{n}^j[x_1 (\\omega_{\\frac{n}{2}}^{0j}) + x_3 (\\omega_{\\frac{n}{2}}^{1j}) + x_5 (\\omega_{\\frac{n}{2}}^{2j}) +...+ x_{n-1} (\\omega_{\\frac{n}{2}}^{\\frac{(n-2)}{2}j})]\r\n\\\\\r\n&=[x_0 (\\omega_{\\frac{n}{2}}^{j})^0 + x_2 (\\omega_{\\frac{n}{2}}^{j})^1 + x_4 (\\omega_{\\frac{n}{2}}^{j})^2 +...+ x_{n-2} (\\omega_{\\frac{n}{2}}^{j})^{\\frac{n-2}{2}}] + \\omega_{n}^j[x_1 (\\omega_{\\frac{n}{2}}^{j})^0 + x_3 (\\omega_{\\frac{n}{2}}^{j})^1 + x_5 (\\omega_{\\frac{n}{2}}^{j})^2 +...+ x_{n-1} (\\omega_{\\frac{n}{2}}^{j})^{\\frac{n-2}{2}}]\r\n\\end{aligned}\r\n$$\r\n\r\n**令**\r\n\r\n$$\r\nf(x)=x_0x^0+x_1x^1+x_2x^2+...+x_{n-1}x^{n-1} \\\\\r\ng(x)=x_0x^0+x_2x^1+x_4x^2+...+x_{n-2}x^{\\frac{n-2}{2}} \\\\\r\nh(x)=x_1x^0+x_3x^1+x_5x^2+...+x_{n-1}x^{\\frac{n-2}{2}} \\\\\r\n$$\r\n\r\n**则**\r\n\r\n$$\r\n\\begin{aligned}\r\nX_j &= f(\\omega_n^j)=g(\\omega_{\\frac{n}{2}}^j)+\\omega_n^j \\cdot h(\\omega_{\\frac{n}{2}}^j) \\quad (9)\r\n\\\\\r\nX_{j+\\frac{n}{2}} &= f(\\omega_n^{j+\\frac{n}{2}})=g(\\omega_{\\frac{n}{2}}^{j+\\frac{n}{2}})+\\omega_n^{j+\\frac{n}{2}} \\cdot h(\\omega_{\\frac{n}{2}}^{j+\\frac{n}{2}})\r\n\\\\ &\\Downarrow \\\\\r\nX_{j+\\frac{n}{2}} &= g(\\omega_{\\frac{n}{2}}^j)-\\omega_n^j \\cdot h(\\omega_{\\frac{n}{2}}^j) \\quad (10)\r\n\\end{aligned}\r\n$$\r\n\r\n**即：**\r\n\r\n$$\r\nX_j = f(\\omega_n^j) =\r\n\\begin{cases}\r\ng(\\omega_{\\frac{n}{2}}^j)+\\omega_n^j \\cdot h(\\omega_{\\frac{n}{2}}^j), & j< \\frac{n}{2}\r\n\\\\\r\ng(\\omega_{\\frac{n}{2}}^j)-\\omega_n^j \\cdot h(\\omega_{\\frac{n}{2}}^j), & j\\ge \\frac{n}{2}\r\n\\end{cases}\r\n$$\r\n\r\n于是我们就可以**不断地将当前序列按奇偶项分成两个序列进行递归求解**，**直到当前每个序列中都只含有一个元素，此时 $\\omega_1^0=\\omega_1^1=1$**，由于每次递归每个序列中的元素个数减半，因此**最多递归 $\\log_2^n$ 次**，**回溯时每轮计算 n 个元素的值**，每个元素的计算都只需要一次乘法和一次加减法，因此**总体复杂度为 $O(n\\log n)$**\r\n\r\n**对于逆变换，将上述过程中所有单位复根的指数乘以-1，再将最后的计算结果乘以 $\\frac{1}{n}$ 即可**\r\n\r\n**具体递归过程如下图所示：**\r\n\r\n![](./assets/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2(FFT)/2021-07-23-14-15-46.png)\r\n\r\n#### 4.5.2. 代码实现\r\n\r\n现在我们来一步一步实现这个算法。\r\n\r\n首先，**能一直递归下去的条件是 $n$ 是 $2$ 的整次幂**，但是这个条件很容易满足，若多项式项数不满足这个条件，我们就为其**补充系数为 0 的项**即可，系数为 0 的项不影响计算。\r\n\r\n我们可以**通过计算 $\\log_2{(n+1)}+1$ 来得到需要将项数补充到 2 的多少次幂**：\r\n\r\n```cpp\r\nint N = 1 << __lg(n + 1) + 1;\r\n```\r\n\r\n之所以是 n+1 而不是 n，是因为可能出现 0 次多项式，我们要避免计算 $\\log_2 0$\r\n\r\n我们这里的计算大部分是在**复数域**上进行的，我们可以使用 `<complex>` 中提供的**复数模板类**：\r\n\r\n```cpp\r\ntypedef complex<double> comp; // 重命名一下以免麻烦\r\n```\r\n\r\n定义一些**常量**：\r\n\r\n```cpp\r\nconst comp I(0, 1);//辐角为90°的单位复根\r\nconst double PI = acos(-1); // 环境允许也可以使用M_PI\r\n```\r\n\r\n注意到**离散傅里叶变换(DFT)与其逆变换之间之间只有很小的区别**，所以我们**可以只用一个函数实现两者的功能**：\r\n\r\n```cpp\r\n// 把F从频域变换到时域，或从时域变换到频域\r\nvoid fft(comp F[], int N, int sgn = 1); // sgn = 1表示DFT，-1表示其逆变换\r\n```\r\n\r\n**递归出口是 N=1，这时频域和时域相同（都只有一个数，且$\\omega_1^0=\\omega_1^1=\\omega_1^{-1}=1$）：**\r\n\r\n```cpp\r\nif (N == 1)\r\n    return;\r\n```\r\n\r\n先把**偶数项**放到 F 的**前半部分**，**奇数项**放到**后半部分**：\r\n\r\n```cpp\r\nmemcpy(tmp, F, sizeof(comp) * N); // 先复制一个临时数组\r\nfor (int i = 0; i < N; i++)\r\n    *(i % 2 ? F + i / 2 + N / 2 : F + i / 2) = tmp[i]; // 这里写得有点花哨，也可以展开成if-else\r\n```\r\n\r\n**递归地对前半部分和后半部分进行变换**，**回溯时按轮计算每轮每个序列中每个元素的值**：\r\n\r\n```cpp\r\nfft(F, N / 2, sgn), fft(F + N / 2, N / 2, sgn);\r\n```\r\n\r\n然后按刚刚推导的公式进行计算即可：\r\n\r\n```cpp\r\ncomp *G = F, *H = F + N / 2;  // 用指针比较直观\r\n//单位复根可以递推计算，逆变换要多乘一个-1\r\ncomp cur = 1, step = exp(2 * PI / N * sgn * I);\r\n//使用 STL的complex可以调用exp函数求出ω_n，与使用欧拉公式来将ω_n转化为三角函数形式的复数等价\r\n\r\nfor (int k = 0; k < N / 2; k++)\r\n{\r\n    tmp[k] = G[k] + cur * H[k];\r\n    tmp[k + N / 2] = G[k] - cur * H[k];\r\n    cur *= step;//累乘单位复根\r\n}\r\n//当前轮元素计算完毕，将全部元素复制回原数组\r\nmemcpy(F, tmp, sizeof(comp) * N);\r\n// 这里逆变换没有除以N，因为复数除法很慢，可以等要用到时先用real()求实部再除以N\r\n```\r\n\r\n于是现在就可以通过洛谷的模板题[P3803](https://www.luogu.com.cn/problem/P3803)了：\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <complex>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\ninline int read()\r\n{\r\n    int ans = 0;\r\n    char c = getchar();\r\n    while (!isdigit(c))\r\n        c = getchar();\r\n    while (isdigit(c))\r\n    {\r\n        ans = ans * 10 + c - '0';\r\n        c = getchar();\r\n    }\r\n    return ans;\r\n}\r\ntypedef complex<double> comp;\r\nconst int MAXN = 1000005;\r\nconst comp I(0, 1);\r\nconst double PI = acos(-1);\r\ncomp A[MAXN * 3], B[MAXN * 3], tmp[MAXN * 3], ans[MAXN * 3]; // 数组开大一些\r\nvoid fft(comp F[], int N, int sgn = 1)\r\n{\r\n    if (N == 1)\r\n        return;\r\n    memcpy(tmp, F, sizeof(comp) * N);\r\n    for (int i = 0; i < N; i++)\r\n        *(i % 2 ? F + i / 2 + N / 2 : F + i / 2) = tmp[i];\r\n    fft(F, N / 2, sgn), fft(F + N / 2, N / 2, sgn);\r\n    comp *G = F, *H = F + N / 2;\r\n    comp cur = 1, step = exp(2 * PI / N * sgn * I);\r\n    for (int k = 0; k < N / 2; k++)\r\n    {\r\n        tmp[k] = G[k] + cur * H[k];\r\n        tmp[k + N / 2] = G[k] - cur * H[k];\r\n        cur *= step;\r\n    }\r\n    memcpy(F, tmp, sizeof(comp) * N);\r\n}\r\nint main()\r\n{\r\n    int n = read(), m = read(), N = 1 << __lg(n + m + 1) + 1; // 补成2的整次幂\r\n    for (int i = 0; i <= n; ++i)\r\n        A[i] = read();\r\n    for (int i = 0; i <= m; ++i)\r\n        B[i] = read();\r\n    fft(A, N), fft(B, N);\r\n    for (int i = 0; i < N; ++i)\r\n        ans[i] = A[i] * B[i];\r\n    fft(ans, N, -1);\r\n    for (int i = 0; i <= n + m; ++i)\r\n        printf(\"%d \", int(ans[i].real() / N + 0.1)); // +0.1规避浮点误差\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 4.5.3. 快速傅里叶变换的优化\r\n\r\n##### 4.5.3.1. 蝴蝶变换\r\n\r\n然而，这个实现方式需要把数组复制过来复制过去，不免还是有点慢，我们可以对其进行**常数优化**：\r\n\r\n为了**避免反复的拷贝**，我们可以**提前确定序列中每个元素最后的位置**。**把下标用二进制表示**，对于 8 度多项式，模拟递归过程如下：\r\n\r\n$$\r\n[a_{000} \\quad a_{001} \\quad a_{010} \\quad a_{011} \\quad a_{100} \\quad a_{101} \\quad a_{110} \\quad a_{111}]\r\n$$\r\n\r\n对其按项的奇偶性进行一次递归划分：\r\n\r\n$$\r\n[a_{000} \\quad a_{010} \\quad a_{100} \\quad a_{110}] \\quad [a_{001} \\quad a_{011} \\quad a_{101} \\quad a_{111}]\r\n$$\r\n\r\n再对递归后得到的两个序列再进行一次递归：\r\n\r\n$$\r\n[a_{000} \\quad a_{100}] \\quad [a_{010} \\quad a_{110}] \\quad [a_{001} \\quad a_{101}] \\quad [a_{011} \\quad a_{111}]\r\n$$\r\n\r\n最后得到：\r\n\r\n$$\r\n[a_{000}] \\quad [a_{100}] \\quad [a_{010}] \\quad [a_{110}] \\quad [a_{001}] \\quad [a_{101}] \\quad [a_{011}] \\quad [a_{111}]\r\n$$\r\n\r\n观察一下我们可以发现：**最后得到的每个元素的下标，都是其最初时下标的二进制表示的翻转。**\r\n\r\n我们称这个变换为**位逆序置换（bit-reversal permutation，国内也称蝴蝶变换）**，我们**通过蝴蝶变换，就可以提前让序列就位**，然后**通过迭代而不是递归地进行求解**，**防止拷贝**。\r\n\r\n蝴蝶变换可以通过**递推** $O(n)$ 地实现：\r\n\r\n我们定义 $rev[i]$ 为数 $i$ 进行翻转之后得到的数，然后可以进行如下递推：\r\n\r\n1. $rev[0]=0$\r\n\r\n2. 对于当前数 $i$，将二进制下的 $i$ 表示为前缀 $head$ +末尾字符 $tail$ 的形式，则数 $i$ 翻转的结果即为 $head$ 翻转再右移一位之后再在其开头加上 $tail$ 之后的结果  \r\n   例如对于 $1101$，$head=0110,tail=1$，$head$ 的翻转为 $0110$，将其右移一位之后得到 $011$，将 $tail$ 加到其头部之后得到 $1011$，即为 $1101$ 的翻转\r\n\r\n3. 对于当前数 $i$，其 $head$ 表示的数即为 $i>>1(\\lfloor\\frac{i}{2}\\rfloor)$ ，而 $i>>1$ 翻转之后的结果 $rev[i>>1]$ 在之前已经被计算过了，因此我们只需要将 $tail$ 加到 $rev[i>>1]$ 的开头即可得到数 $i$ 翻转之后的结果\r\n\r\n4. 若 $tail=0$，相当于不做任何处理，若 $tail=1$ ，则需要将 $tail$ 左移到最高位之后加在 $rev[i>>1]$ 上\r\n\r\n5. 因此对 $rev[i]$ 的计算过程可用代码表示为：`rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit)` ，bit 为总位数-1( $2^x=$ 多项式补充后的总项数 N，$bit=x-1$)\r\n\r\n还需要注意的是二进制数的翻转要么是两个数一对，要么是翻转后的数是其自身，若翻转后是其自身则不用改变位置，若是两个数一对相互翻转可以互相得到，则要注意只交换一次，防止将系数交换到它的最终位置后又将其交换回去\r\n\r\n```cpp\r\nint bit = __lg(N) - 1;\r\nfor (int i = 0; i < N; ++i)\r\n{\r\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit);\r\n    if (i < rev[i])  // 这里要防止防止重复交换\r\n        swap(a[i], a[rev[i]]);\r\n}\r\n```\r\n\r\n由于每个数的位置都已经确定了，现在我们就完全可以用迭代的方式进行快速傅里叶变换的计算，代码如下：\r\n\r\n```cpp\r\n// 非递归版FFT，确保N是2的整次幂\r\nint rev[MAXN * 3];\r\nconst comp I(0, 1);//辐角为90°的单位复根\r\nconst double PI = acos(-1);\r\nvoid fft(comp F[], int N, int sgn = 1)\r\n{\r\n    int bit = __lg(N)-1;\r\n    for (int i = 0; i < N; ++i) // 蝴蝶变换\r\n    {\r\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit);\r\n        if (i < rev[i])\r\n            swap(F[i], F[rev[i]]);\r\n    }\r\n    for (int l = 1; l < N; l <<= 1) // 枚举合并前的区间长度\r\n    {\r\n        comp step = exp(sgn * PI / l * I);//当前需要累乘区间长度(2l)次单位复根(2pi/2l=pi/l)\r\n        for (int i = 0; i < N; i += l * 2) // 遍历起始点\r\n        {\r\n            comp cur(1, 0);//从ω_(2l)^0开始\r\n            for (int k = i; k < i + l; ++k)//遍历半个区间，两个两个计算区间元素\r\n            {\r\n                comp g = F[k], h = F[k + l] * cur;\r\n                F[k] = g + h, F[k + l] = g - h;\r\n                cur *= step;//累乘单位复根\r\n            }\r\n        }\r\n    }\r\n}\r\n// 逆变换记得在外部把实部除以N\r\n```\r\n\r\n这个方法比朴素的递归 FFT 快了近一倍，也是最常用的版本。\r\n\r\n##### 4.5.3.2. \"三步变两步\"优化\r\n\r\n对于多项式乘法，还有一个“三步变两步”优化：设 $P$ 和 $Q$ 是 实多项式，$F=P+Qi$ ，则 $F^2=P^2-Q^2+2PQi$ ，注意到我们要求的 $PQ$ 正是 $F$ 虚部的一半。这样**只需要两次 FFT** 就可以求出结果。\r\n\r\n```cpp\r\nfor (int i = 0; i <= n; ++i)\r\n    A[i] = read();\r\nfor (int i = 0; i <= m; ++i)\r\n    B[i] = read();\r\nfor (int i = 0; i <= max(n, m); ++i)\r\n    F[i] = comp(A[i], B[i]);\r\nfft(F, N);\r\nfor (int i = 0; i < N; ++i)\r\n    F[i] = F[i] * F[i];\r\nfft(F, N, -1);\r\nfor (int i = 0; i <= n + m; ++i)\r\n    printf(\"%d \", int(F[i].imag() / (N * 2) + 0.1));\r\n```\r\n\r\n## 5. 代码模板\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <complex>\r\nusing namespace std;\r\ntypedef complex<double> comp;\r\nconst int maxn = 1e5 + 5;\r\n// 非递归版FFT，确保N是2的整次幂\r\nint rev[maxn * 3];\r\nconst comp I(0, 1); //辐角为90°的单位复根\r\nconst double PI = acos(-1);\r\nvoid fft(comp F[], int N, int sgn = 1)\r\n{\r\n    int bit = __lg(N) - 1;\r\n    for (int i = 0; i < N; ++i) // 蝴蝶变换\r\n    {\r\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit);\r\n        if (i < rev[i])\r\n            swap(F[i], F[rev[i]]);\r\n    }\r\n    for (int l = 1; l < N; l <<= 1) // 枚举合并前的区间长度\r\n    {\r\n        comp step = exp(sgn * PI / l * I); //当前需要累乘区间长度(2l)次单位复根(2pi/2l=pi/l)\r\n        for (int i = 0; i < N; i += l * 2) // 遍历起始点\r\n        {\r\n            comp cur(1, 0);                 //从ω_(2l)^0开始\r\n            for (int k = i; k < i + l; ++k) //遍历半个区间，两个两个计算区间元素\r\n            {\r\n                comp g = F[k], h = F[k + l] * cur;\r\n                F[k] = g + h, F[k + l] = g - h;\r\n                cur *= step; //累乘单位复根\r\n            }\r\n        }\r\n    }\r\n}\r\n// 逆变换记得在外部把实部除以N\r\n```\r\n\r\n## 6. 相关题目\r\n\r\n### 6.1. 使用快速傅里叶变换加速计算大整数乘法\r\n\r\n-   模板题：[洛谷 P1919](https://www.luogu.com.cn/problem/P1919)\r\n\r\n对于每一个 $n$ 位的十进制数，我们可以将其看做一个 $n-1$ 次多项式 $F$，满足：\r\n\r\n$$\r\nF(x)=a_0+a_1\\times 10 +a_2\\times 10^2 +...+ a_{n-1}\\times 10^{n-1}\r\n$$\r\n\r\n于是我们就可以使用快速傅里叶变换加速大整数乘法了，要注意多项式的项数设置以及最终结果的进位处理\r\n\r\n代码如下：\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <complex>\r\n#include <string>\r\nusing namespace std;\r\ntypedef complex<double> comp;\r\nconst int maxn = 1e6 + 5;\r\n// 非递归版FFT，确保N是2的整次幂\r\nint rev[maxn * 4];\r\nconst comp I(0, 1); //辐角为90°的单位复根\r\nconst double PI = acos(-1);\r\nvoid fft(comp F[], int N, int sgn = 1)\r\n{\r\n    int bit = __lg(N) - 1;\r\n    for (int i = 0; i < N; ++i) // 蝴蝶变换\r\n    {\r\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit);\r\n        if (i < rev[i])\r\n            swap(F[i], F[rev[i]]);\r\n    }\r\n    for (int l = 1; l < N; l <<= 1) // 枚举合并前的区间长度\r\n    {\r\n        comp step = exp(sgn * PI / l * I); //当前需要累乘区间长度(2l)次单位复根(2pi/2l=pi/l)\r\n        for (int i = 0; i < N; i += l * 2) // 遍历起始点\r\n        {\r\n            comp cur(1, 0);                 //从ω_(2l)^0开始\r\n            for (int k = i; k < i + l; ++k) //遍历半个区间，两个两个计算区间元素\r\n            {\r\n                comp g = F[k], h = F[k + l] * cur;\r\n                F[k] = g + h, F[k + l] = g - h;\r\n                cur *= step; //累乘单位复根\r\n            }\r\n        }\r\n    }\r\n}\r\ncomp A[maxn * 4], B[maxn * 4];\r\nint ans[maxn * 4];\r\n// 逆变换记得在外部把实部除以N\r\nint main()\r\n{\r\n    string a, b;\r\n    cin >> a >> b;\r\n    int len1 = a.length(), len2 = b.length();\r\n    int k1 = 0, k2 = 0;\r\n    for (int i = len1 - 1; i >= 0; i--)\r\n        A[k1++] = a[i] - '0';\r\n    for (int i = len2 - 1; i >= 0; i--)\r\n        B[k2++] = b[i] - '0';\r\n    int N = 1;\r\n    while (N < len1 + len2)\r\n        N <<= 1;\r\n    fft(A, N, 1);\r\n    fft(B, N, 1);\r\n    for (int i = 0; i < N; i++)\r\n        A[i] = A[i] * B[i];\r\n    fft(A, N, -1);\r\n    bool flag = 0;\r\n    int N2 = N;\r\n    for (int i = 0; i < N2; i++)\r\n    {\r\n        ans[i] += A[i].real() / N + 0.1;\r\n        if (ans[i] >= 10)\r\n        {\r\n            ans[i + 1] += ans[i] / 10;\r\n            ans[i] %= 10;\r\n        }\r\n    }\r\n    for (int i = N2 - 1; i >= 0; i--)\r\n    {\r\n        if (!flag && ans[i] != 0)\r\n            flag = 1;\r\n        if (flag)\r\n            cout << ans[i];\r\n    }\r\n}\r\n```\r\n";const d=r({setup(r){const d=a("");return(r,a)=>(_(),e(o,null,[i($(n),{modelValue:d.value,"onUpdate:modelValue":a[0]||(a[0]=n=>d.value=n)},null,8,["modelValue"]),i($(n),{modelValue:$(c),"onUpdate:modelValue":a[1]||(a[1]=n=>t(c)?c.value=n:null),"preview-only":""},null,8,["modelValue"])],64))}});export{d as default};
